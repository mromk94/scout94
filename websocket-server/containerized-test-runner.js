/**
 * Containerized Test Runner
 * Phase 2: Complete Integration
 * 
 * Purpose: Orchestrate containerized testing with auto-generated databases
 */

import { TestContainerManager } from './test-container-manager.js';
import { SchemaParser } from './schema-parser.js';
import { TestDataGenerator } from './test-data-generator.js';
import { DockerChecker } from './docker-checker.js';
import { existsSync } from 'fs';

export class ContainerizedTestRunner {
  constructor() {
    this.containerManager = new TestContainerManager();
    this.schemaParser = new SchemaParser();
    this.dataGenerator = new TestDataGenerator();
    this.dockerChecker = new DockerChecker();
    this.activeContainers = [];
  }

  /**
   * Run containerized tests with configuration
   */
  async runContainerizedTests(config, projectPath, broadcast) {
    const testEnv = config.testEnvironment;
    
    // Check if containerized testing is enabled
    if (!testEnv?.containerized) {
      return {
        skipped: true,
        reason: 'Containerized testing not enabled in settings'
      };
    }

    broadcast({
      type: 'message',
      agent: 'scout94',
      text: 'üê≥ **Containerized Testing Phase**\n\nChecking Docker availability...',
      contentType: 'markdown',
      timestamp: new Date().toISOString()
    });

    // Check Docker availability
    const dockerStatus = await this.dockerChecker.checkDocker();
    
    if (!dockerStatus.ready) {
      const errorMsg = this.dockerChecker.formatErrorMessage(dockerStatus);
      broadcast({
        type: 'message',
        agent: 'scout94',
        text: errorMsg,
        contentType: 'markdown',
        timestamp: new Date().toISOString()
      });
      
      return {
        skipped: true,
        reason: dockerStatus.error,
        dockerStatus
      };
    }

    broadcast({
      type: 'message',
      agent: 'scout94',
      text: `‚úÖ Docker ready: ${dockerStatus.version}\n\nSetting up isolated test environment...`,
      timestamp: new Date().toISOString()
    });

    try {
      const results = {
        dockerStatus,
        database: null,
        testEnvironment: null,
        testData: null,
        testsRun: [],
        cleanup: { success: false }
      };

      // STEP 1: Create test database if enabled
      if (testEnv.autoGenerateDB && testEnv.schemaPath) {
        results.database = await this.setupTestDatabase(testEnv, broadcast);
      }

      // STEP 2: Create test environment container
      results.testEnvironment = await this.setupTestEnvironment(
        testEnv,
        projectPath,
        results.database,
        broadcast
      );

      // STEP 3: Run tests against containerized environment
      results.testsRun = await this.runTests(
        results.testEnvironment,
        results.database,
        broadcast
      );

      // STEP 4: Cleanup
      results.cleanup = await this.cleanup(testEnv, broadcast);

      return results;

    } catch (error) {
      broadcast({
        type: 'message',
        agent: 'scout94',
        text: `‚ùå **Containerized Testing Error**\n\n\`\`\`\n${error.message}\n\`\`\`\n\nCleaning up and continuing with standard tests...`,
        contentType: 'markdown',
        timestamp: new Date().toISOString()
      });

      // Cleanup on error
      await this.cleanup(testEnv, broadcast);

      return {
        error: error.message,
        stack: error.stack
      };
    }
  }

  /**
   * Setup test database container
   */
  async setupTestDatabase(testEnv, broadcast) {
    broadcast({
      type: 'message',
      agent: 'scout94',
      text: `üóÑÔ∏è Creating ${testEnv.dbType.toUpperCase()} test database...\n- Schema: ${testEnv.schemaPath}\n- Test data: ${testEnv.testDataRows} rows/table`,
      timestamp: new Date().toISOString()
    });

    // Check if schema file exists
    if (!existsSync(testEnv.schemaPath)) {
      throw new Error(`Schema file not found: ${testEnv.schemaPath}`);
    }

    // Parse schema
    const schema = this.schemaParser.parseSchema(testEnv.schemaPath, testEnv.dbType);
    const complexity = this.schemaParser.analyzeComplexity(schema);
    
    broadcast({
      type: 'message',
      agent: 'scout94',
      text: `üìã Schema analyzed:\n- Tables: ${schema.tables.length}\n- Relationships: ${schema.relationships.length}\n- Complexity: ${complexity.complexity}`,
      timestamp: new Date().toISOString()
    });

    // Generate test data
    const testData = await this.dataGenerator.generateForSchema(
      testEnv.schemaPath,
      testEnv.dbType,
      testEnv.testDataRows
    );

    broadcast({
      type: 'message',
      agent: 'scout94',
      text: `‚ú® Test data generated:\n- Total rows: ${testData.stats.totalRows}\n- Tables populated: ${testData.stats.totalTables}`,
      timestamp: new Date().toISOString()
    });

    // Create database container
    const dbContainer = await this.containerManager.createTestDatabase({
      type: testEnv.dbType,
      schemaPath: testEnv.schemaPath,
      port: testEnv.dbPort,
      testDataRows: testEnv.testDataRows
    });

    this.activeContainers.push(dbContainer);

    broadcast({
      type: 'message',
      agent: 'scout94',
      text: `‚úÖ Test database ready on port ${dbContainer.port}`,
      timestamp: new Date().toISOString()
    });

    return {
      ...dbContainer,
      schema,
      testData: testData.stats
    };
  }

  /**
   * Setup test environment container
   */
  async setupTestEnvironment(testEnv, projectPath, database, broadcast) {
    broadcast({
      type: 'message',
      agent: 'scout94',
      text: `üöÄ Creating test environment...\n- Image: ${testEnv.baseImage}\n- Port: ${testEnv.port}`,
      timestamp: new Date().toISOString()
    });

    const envVars = {};
    if (database) {
      envVars.DB_HOST = database.credentials.host;
      envVars.DB_PORT = database.credentials.port;
      envVars.DB_NAME = database.credentials.database;
      envVars.DB_USER = database.credentials.user;
      envVars.DB_PASS = database.credentials.password;
    }

    const appContainer = await this.containerManager.createTestEnvironment({
      projectPath,
      baseImage: testEnv.baseImage,
      testPort: testEnv.port,
      envVars
    });

    this.activeContainers.push(appContainer);

    broadcast({
      type: 'message',
      agent: 'scout94',
      text: `‚úÖ Test environment ready at ${appContainer.url}`,
      timestamp: new Date().toISOString()
    });

    return appContainer;
  }

  /**
   * Run tests against containerized environment
   */
  async runTests(testEnv, database, broadcast) {
    broadcast({
      type: 'message',
      agent: 'scout94',
      text: 'üß™ Running tests in isolated environment...',
      timestamp: new Date().toISOString()
    });

    const tests = [];

    // Test 1: Environment accessibility
    try {
      const response = await fetch(testEnv.url);
      tests.push({
        name: 'Environment Accessibility',
        status: response.status < 500 ? 'PASS' : 'FAIL',
        details: `HTTP ${response.status}`
      });
    } catch (error) {
      tests.push({
        name: 'Environment Accessibility',
        status: 'FAIL',
        details: error.message
      });
    }

    // Test 2: Database connectivity (if database exists)
    if (database) {
      tests.push({
        name: 'Database Connectivity',
        status: 'PASS', // Container creation already verified this
        details: `Connected to ${database.type} on port ${database.port}`
      });
    }

    broadcast({
      type: 'message',
      agent: 'scout94',
      text: `‚úÖ Containerized tests complete:\n${tests.map(t => `- ${t.name}: ${t.status}`).join('\n')}`,
      timestamp: new Date().toISOString()
    });

    return tests;
  }

  /**
   * Cleanup containers
   */
  async cleanup(testEnv, broadcast) {
    if (!testEnv.autoCleanup) {
      broadcast({
        type: 'message',
        agent: 'scout94',
        text: '‚è∏Ô∏è Auto-cleanup disabled - containers left running for inspection',
        timestamp: new Date().toISOString()
      });
      return { skipped: true };
    }

    broadcast({
      type: 'message',
      agent: 'scout94',
      text: 'üßπ Cleaning up containers...',
      timestamp: new Date().toISOString()
    });

    try {
      for (const container of this.activeContainers) {
        if (container.cleanup) {
          await container.cleanup();
        }
      }

      this.activeContainers = [];

      broadcast({
        type: 'message',
        agent: 'scout94',
        text: '‚úÖ Cleanup complete',
        timestamp: new Date().toISOString()
      });

      return { success: true };
    } catch (error) {
      broadcast({
        type: 'message',
        agent: 'scout94',
        text: `‚ö†Ô∏è Cleanup warning: ${error.message}`,
        timestamp: new Date().toISOString()
      });

      return { success: false, error: error.message };
    }
  }
}

export default new ContainerizedTestRunner();
